---
title: "My two greatest challenges while learning software development"
date: 2019-01-16T11:31:12+03:00
---
>‚ÄúThe greater our knowledge increases, the greater our ignorance unfolds.‚Äù ‚Äï John F. Kennedy

I studied Computer Science at school. Specialized in the software side of it. After graduation, I felt like I knew quite a lot. I‚Äôd done a couple of projects in class, and a few side projects so coding wasn‚Äôt really new to me. Now I could be paid to write software, right? Wrong.

What I didn‚Äôt know was that there was a lot more that went into software development than just writing code that worked. There was a lot more that I needed to learn. And I mean a lot.

## OOP

I hated Java and C++ in school. Why, you ask? Classes, objects, methods. I never understood them and didn‚Äôt care to. Why should you complicate your code? Just write a function that takes care of what you need. You need something else taken care of? Write another function. It could be because my first language was C, but writing code in the traditional top-down approach of structured programming just worked for me. I stuck with Javascript after C because I knew I could get away with sticking to functions üòÖ.

Long story short, I couldn‚Äôt get away with it for long. There are a lot of benefits to going the OOP way. I knew this, theoretically, but it really hit me when working on a boot camp project developing an API with Python. I realized there was too much repetition in my code. Files were getting really large and things were getting out of hand. There must be a better way to do this, I thought. Classes. Methods. Inheritance. I had to learn OOP.

Getting to wrap my head around it has not been easy, but since I did, programming has never been more enjoyable. I feel like I have a better understanding of the codebase, and everything just fits together so nicely. Which brings me to the next thing:

## TDD

Yes, I learnt about testing in school. Blackbox testing. White box testing. All the theory. But I never thought of testing in terms of test-driven development. I thought testing was for users. Just write the software and see if it works. If it does, release it and work on improvements later. If someone says it doesn‚Äôt work, well‚Ä¶
![works-on-my-machine](https://cdn-images-1.medium.com/max/800/1*Zv0hpjbZziG7YsjT9PKaYg.jpeg)

Again, I heard to learn this from scratch. It was pretty hectic since it was completely new to me. I just couldn‚Äôt follow the process: write failing test, write code to make the tests pass, refractor. I preferred my own way: write code, write tests to pass, refractor. But I found that that also didn‚Äôt hold up very well when I found out my tests passed even when the output was wrong. There‚Äôs a reason to the systems that exist.

I‚Äôve learned that writing tests first really gave me a holistic overview of the task at hand and kind of like a goal that I had to achieve with the code I was writing. This helped in my productivity since I have to focus on one thing at a time, making my code cleaner.

## In conclusion‚Ä¶

There's a lot more that I keep learning with each passing day but I‚Äôd say the most important thing I‚Äôve learned is that if you never get yourself out there to learn new things, you‚Äôll never know what you don‚Äôt know. If I never pushed myself to engage in bigger projects than the ones I was used to, I never would have seen the importance of OOP. If I didn‚Äôt push myself to get into professional development, I never would have seen the importance of tests. It‚Äôs possible to just sit and think you know how things work, but there‚Äôs always more, a lot more that you probably don‚Äôt know. If you feel like you‚Äôve not learned something new for a while, you‚Äôre probably settling into mediocrity. Never settle. Keep growing.
